import { Component, ViewEncapsulation, EventEmitter, Input, Output, } from "@angular/core";
import { create, supported } from "filepond";
import * as i0 from "@angular/core";
// We test if filepond is supported on the current client
const isSupported = supported();
// List of attributes for fallback input
const inputAttributes = [
    "id",
    "name",
    "class",
    "multiple",
    "required",
    "disabled",
    "capture",
    "accept",
];
// Methods not made available on the component
const filteredComponentMethods = [
    "setOptions",
    "on",
    "off",
    "onOnce",
    "appendTo",
    "insertAfter",
    "insertBefore",
    "isAttachedTo",
    "replaceElement",
    "restoreElement",
    "destroy",
];
const outputs = [
    "oninit",
    "onwarning",
    "onerror",
    "oninitfile",
    "onaddfilestart",
    "onaddfileprogress",
    "onaddfile",
    "onprocessfilestart",
    "onprocessfileprogress",
    "onprocessfileabort",
    "onprocessfilerevert",
    "onprocessfile",
    "onprocessfiles",
    "onremovefile",
    "onpreparefile",
    "onupdatefiles",
    "onactivatefile",
    "onreorderfiles",
];
// Component outline
export class FilePondComponent {
    constructor(root, zone) {
        this.options = {};
        // same as outputs array
        this.oninit = new EventEmitter();
        this.onwarning = new EventEmitter();
        this.onerror = new EventEmitter();
        this.oninitfile = new EventEmitter();
        this.onactivatefile = new EventEmitter();
        this.onaddfilestart = new EventEmitter();
        this.onaddfileprogress = new EventEmitter();
        this.onaddfile = new EventEmitter();
        this.onprocessfilestart = new EventEmitter();
        this.onprocessfileprogress = new EventEmitter();
        this.onprocessfileabort = new EventEmitter();
        this.onprocessfilerevert = new EventEmitter();
        this.onprocessfile = new EventEmitter();
        this.onprocessfiles = new EventEmitter();
        this.onremovefile = new EventEmitter();
        this.onpreparefile = new EventEmitter();
        this.onupdatefiles = new EventEmitter();
        this.onreorderfiles = new EventEmitter();
        this.pond = null;
        this.handleEvent = null;
        this.root = root;
        this.zone = zone;
    }
    ngAfterViewInit() {
        const input = this.root.nativeElement.querySelector("input");
        // transfer relevant attributes to input, this so we still have an input with the correct attributes should file pond not load
        const attributes = this.root.nativeElement.attributes;
        inputAttributes.forEach((name) => {
            const value = attributes[name]
                ? attributes[name].value
                : this.options[name];
            if (!value) {
                return;
            }
            input.setAttribute(name, value);
        });
        // no sufficient features supported in this browser
        if (!isSupported) {
            return;
        }
        // map FilePond events to Angular @outputs
        this.handleEvent = (e) => {
            const key = `on${e.type.split(":")[1]}`;
            // @ts-ignore
            this[key].emit({ ...e.detail });
        };
        outputs.forEach((event) => {
            this.root.nativeElement.addEventListener(`FilePond:${event.substring(2)}`, this.handleEvent);
        });
        // will block angular from listening to events inside the pond
        this.zone.runOutsideAngular(() => {
            // create instance
            this.pond = create(input, {
                // our options
                ...this.options,
                // our initial files
                files: this.files,
            });
        });
        // Copy instance method references to component instance
        this.pond &&
            Object.keys(this.pond)
                // remove unwanted methods
                .filter((key) => filteredComponentMethods.indexOf(key) === -1)
                // set method references from the component instance to the pond instance
                .forEach((key) => {
                // @ts-ignore
                this[key] = this.pond[key];
            });
    }
    ngOnChanges(changes) {
        // no need to handle first change
        if (changes["firstChange"])
            return;
        // no filepond instance available
        if (!this.pond) {
            return;
        }
        // use new options object as base ( or if not available, use current options )
        const options = changes["options"]
            ? changes["options"].currentValue
            : this.options;
        // see if file list has changed
        if (changes["files"] &&
            JSON.stringify(changes["files"].previousValue) !==
                JSON.stringify(changes["files"].currentValue)) {
            // file list has changed
            options.files = changes["files"].currentValue;
        }
        // set new options
        this.pond.setOptions(options);
    }
    ngOnDestroy() {
        if (!this.pond) {
            return;
        }
        outputs.forEach((event) => {
            this.root.nativeElement.removeEventListener(`FilePond:${event.substring(2)}`, this.handleEvent);
        });
        this.pond.destroy();
    }
}
FilePondComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.1", ngImport: i0, type: FilePondComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
FilePondComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.1", type: FilePondComponent, selector: "file-pond", inputs: { options: "options", files: "files" }, outputs: { oninit: "oninit", onwarning: "onwarning", onerror: "onerror", oninitfile: "oninitfile", onactivatefile: "onactivatefile", onaddfilestart: "onaddfilestart", onaddfileprogress: "onaddfileprogress", onaddfile: "onaddfile", onprocessfilestart: "onprocessfilestart", onprocessfileprogress: "onprocessfileprogress", onprocessfileabort: "onprocessfileabort", onprocessfilerevert: "onprocessfilerevert", onprocessfile: "onprocessfile", onprocessfiles: "onprocessfiles", onremovefile: "onremovefile", onpreparefile: "onpreparefile", onupdatefiles: "onupdatefiles", onreorderfiles: "onreorderfiles" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"filepond--wrapper\">\n  <input type=\"file\"/>\n</div>", styles: [""], encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.1", ngImport: i0, type: FilePondComponent, decorators: [{
            type: Component,
            args: [{ selector: "file-pond", encapsulation: ViewEncapsulation.None, template: "<div class=\"filepond--wrapper\">\n  <input type=\"file\"/>\n</div>" }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { options: [{
                type: Input
            }], files: [{
                type: Input
            }], oninit: [{
                type: Output
            }], onwarning: [{
                type: Output
            }], onerror: [{
                type: Output
            }], oninitfile: [{
                type: Output
            }], onactivatefile: [{
                type: Output
            }], onaddfilestart: [{
                type: Output
            }], onaddfileprogress: [{
                type: Output
            }], onaddfile: [{
                type: Output
            }], onprocessfilestart: [{
                type: Output
            }], onprocessfileprogress: [{
                type: Output
            }], onprocessfileabort: [{
                type: Output
            }], onprocessfilerevert: [{
                type: Output
            }], onprocessfile: [{
                type: Output
            }], onprocessfiles: [{
                type: Output
            }], onremovefile: [{
                type: Output
            }], onpreparefile: [{
                type: Output
            }], onupdatefiles: [{
                type: Output
            }], onreorderfiles: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWZpbGVwb25kLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1maWxlcG9uZC9zcmMvbGliL25neC1maWxlcG9uZC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtZmlsZXBvbmQvc3JjL2xpYi9uZ3gtZmlsZXBvbmQuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFHVCxpQkFBaUIsRUFDakIsWUFBWSxFQUVaLEtBQUssRUFDTCxNQUFNLEdBSVAsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQTZCLE1BQU0sVUFBVSxDQUFDOztBQUV4RSx5REFBeUQ7QUFDekQsTUFBTSxXQUFXLEdBQVksU0FBUyxFQUFFLENBQUM7QUFFekMsd0NBQXdDO0FBQ3hDLE1BQU0sZUFBZSxHQUFrQjtJQUNyQyxJQUFJO0lBQ0osTUFBTTtJQUNOLE9BQU87SUFDUCxVQUFVO0lBQ1YsVUFBVTtJQUNWLFVBQVU7SUFDVixTQUFTO0lBQ1QsUUFBUTtDQUNULENBQUM7QUFFRiw4Q0FBOEM7QUFDOUMsTUFBTSx3QkFBd0IsR0FBa0I7SUFDOUMsWUFBWTtJQUNaLElBQUk7SUFDSixLQUFLO0lBQ0wsUUFBUTtJQUNSLFVBQVU7SUFDVixhQUFhO0lBQ2IsY0FBYztJQUNkLGNBQWM7SUFDZCxnQkFBZ0I7SUFDaEIsZ0JBQWdCO0lBQ2hCLFNBQVM7Q0FDVixDQUFDO0FBRUYsTUFBTSxPQUFPLEdBQWtCO0lBQzdCLFFBQVE7SUFDUixXQUFXO0lBQ1gsU0FBUztJQUNULFlBQVk7SUFDWixnQkFBZ0I7SUFDaEIsbUJBQW1CO0lBQ25CLFdBQVc7SUFDWCxvQkFBb0I7SUFDcEIsdUJBQXVCO0lBQ3ZCLG9CQUFvQjtJQUNwQixxQkFBcUI7SUFDckIsZUFBZTtJQUNmLGdCQUFnQjtJQUNoQixjQUFjO0lB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c0JBQWhCLE1BQU07Z0JBQ0csVUFBVTtzQkFBbkIsTUFBTTtnQkFDRyxjQUFjO3NCQUF2QixNQUFNO2dCQUNHLGNBQWM7c0JBQXZCLE1BQU07Z0JBQ0csaUJBQWlCO3NCQUExQixNQUFNO2dCQUNHLFNBQVM7c0JBQWxCLE1BQU07Z0JBQ0csa0JBQWtCO3NCQUEzQixNQUFNO2dCQUNHLHFCQUFxQjtzQkFBOUIsTUFBTTtnQkFDRyxrQkFBa0I7c0JBQTNCLE1BQU07Z0JBQ0csbUJBQW1CO3NCQUE1QixNQUFNO2dCQUNHLGFBQWE7c0JBQXRCLE1BQU07Z0JBQ0csY0FBYztzQkFBdkIsTUFBTTtnQkFDRyxZQUFZO3NCQUFyQixNQUFNO2dCQUNHLGFBQWE7c0JBQXRCLE1BQU07Z0JBQ0csYUFBYTtzQkFBdEIsTUFBTTtnQkFDRyxjQUFjO3NCQUF2QixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBTaW1wbGVDaGFuZ2VzLFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgRXZlbnRFbWl0dGVyLFxuICBOZ1pvbmUsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEFmdGVyVmlld0luaXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG5pbXBvcnQgeyBjcmVhdGUsIHN1cHBvcnRlZCwgRmlsZVBvbmQsIEZpbGVQb25kT3B0aW9ucyB9IGZyb20gXCJmaWxlcG9uZFwiO1xuXG4vLyBXZSB0ZXN0IGlmIGZpbGVwb25kIGlzIHN1cHBvcnRlZCBvbiB0aGUgY3VycmVudCBjbGllbnRcbmNvbnN0IGlzU3VwcG9ydGVkOiBCb29sZWFuID0gc3VwcG9ydGVkKCk7XG5cbi8vIExpc3Qgb2YgYXR0cmlidXRlcyBmb3IgZmFsbGJhY2sgaW5wdXRcbmNvbnN0IGlucHV0QXR0cmlidXRlczogQXJyYXk8c3RyaW5nPiA9IFtcbiAgXCJpZFwiLFxuICBcIm5hbWVcIixcbiAgXCJjbGFzc1wiLFxuICBcIm11bHRpcGxlXCIsXG4gIFwicmVxdWlyZWRcIixcbiAgXCJkaXNhYmxlZFwiLFxuICBcImNhcHR1cmVcIixcbiAgXCJhY2NlcHRcIixcbl07XG5cbi8vIE1ldGhvZHMgbm90IG1hZGUgYXZhaWxhYmxlIG9uIHRoZSBjb21wb25lbnRcbmNvbnN0IGZpbHRlcmVkQ29tcG9uZW50TWV0aG9kczogQXJyYXk8c3RyaW5nPiA9IFtcbiAgXCJzZXRPcHRpb25zXCIsXG4gIFwib25cIixcbiAgXCJvZmZcIixcbiAgXCJvbk9uY2VcIixcbiAgXCJhcHBlbmRUb1wiLFxuICBcImluc2VydEFmdGVyXCIsXG4gIFwiaW5zZXJ0QmVmb3JlXCIsXG4gIFwiaXNBdHRhY2hlZFRvXCIsXG4gIFwicmVwbGFjZUVsZW1lbnRcIixcbiAgXCJyZXN0b3JlRWxlbWVudFwiLFxuICBcImRlc3Ryb3lcIixcbl07XG5cbmNvbnN0IG91dHB1dHM6IEFycmF5PHN0cmluZz4gPSBbXG4gIFwib25pbml0XCIsXG4gIFwib253YXJuaW5nXCIsXG4gIFwib25lcnJvclwiLFxuICBcIm9uaW5pdGZpbGVcIixcbiAgXCJvbmFkZGZpbGVzdGFydFwiLFxuICBcIm9uYWRkZmlsZXByb2dyZXNzXCIsXG4gIFwib25hZGRmaWxlXCIsXG4gIFwib25wcm9jZXNzZmlsZXN0YXJ0XCIsXG4gIFwib25wcm9jZXNzZmlsZXByb2dyZXNzXCIsXG4gIFwib25wcm9jZXNzZmlsZWFib3J0XCIsXG4gIFwib25wcm9jZXNzZmlsZXJldmVydFwiLFxuICBcIm9ucHJvY2Vzc2ZpbGVcIixcbiAgXCJvbnByb2Nlc3NmaWxlc1wiLFxuICBcIm9ucmVtb3ZlZmlsZVwiLFxuICBcIm9ucHJlcGFyZWZpbGVcIixcbiAgXCJvbnVwZGF0ZWZpbGVzXCIsXG4gIFwib25hY3RpdmF0ZWZpbGVcIixcbiAgXCJvbnJlb3JkZXJmaWxlc1wiLFxuXTtcblxuLy8gQ29tcG9uZW50IG91dGxpbmVcbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogXCJmaWxlLXBvbmRcIixcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgdGVtcGxhdGVVcmw6IFwiLi9uZ3gtZmlsZXBvbmQuY29tcG9uZW50Lmh0bWxcIixcbiAgc3R5bGVVcmxzOiBbXCIuL25neC1maWxlcG9uZC5jb21wb25lbnQuY3NzXCJdLFxufSlcbmV4cG9ydCBjbGFzcyBGaWxlUG9uZENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgQElucHV0KClcbiAgb3B0aW9uczogRmlsZVBvbmRPcHRpb25zIHwgYW55ID0ge307XG5cbiAgQElucHV0KClcbiAgZmlsZXM6IEZpbGVQb25kT3B0aW9uc1tcImZpbGVzXCJdO1xuXG4gIC8vIHNhbWUgYXMgb3V0cHV0cyBhcnJheVxuICBAT3V0cHV0KCkgb25pbml0ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIEBPdXRwdXQoKSBvbndhcm5pbmcgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpIG9uZXJyb3IgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpIG9uaW5pdGZpbGUgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpIG9uYWN0aXZhdGVmaWxlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIEBPdXRwdXQoKSBvbmFkZGZpbGVzdGFydCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBAT3V0cHV0KCkgb25hZGRmaWxlcHJvZ3Jlc3MgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpIG9uYWRkZmlsZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBAT3V0cHV0KCkgb25wcm9jZXNzZmlsZXN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIEBPdXRwdXQoKSBvbnByb2Nlc3NmaWxlcHJvZ3Jlc3MgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpIG9ucHJvY2Vzc2ZpbGVhYm9ydCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBAT3V0cHV0KCkgb25wcm9jZXNzZmlsZXJldmVydCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBAT3V0cHV0KCkgb25wcm9jZXNzZmlsZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBAT3V0cHV0KCkgb25wcm9jZXNzZmlsZXMgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpIG9ucmVtb3ZlZmlsZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBAT3V0cHV0KCkgb25wcmVwYXJlZmlsZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBAT3V0cHV0KCkgb251cGRhdGVmaWxlcyA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBAT3V0cHV0KCkgb25yZW9yZGVyZmlsZXMgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICBwcml2YXRlIHJvb3Q6IEVsZW1lbnRSZWY7XG4gIHByaXZhdGUgem9uZTogTmdab25lO1xuICBwcml2YXRlIHBvbmQ6IEZpbGVQb25kIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaGFuZGxlRXZlbnQ6IEZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3Iocm9vdDogRWxlbWVudFJlZiwgem9uZTogTmdab25lKSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLnpvbmUgPSB6b25lO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5yb290Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xuXG4gICAgLy8gdHJhbnNmZXIgcmVsZXZhbnQgYXR0cmlidXRlcyB0byBpbnB1dCwgdGhpcyBzbyB3ZSBzdGlsbCBoYXZlIGFuIGlucHV0IHdpdGggdGhlIGNvcnJlY3QgYXR0cmlidXRlcyBzaG91bGQgZmlsZSBwb25kIG5vdCBsb2FkXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMucm9vdC5uYXRpdmVFbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgaW5wdXRBdHRyaWJ1dGVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXVxuICAgICAgICA/IGF0dHJpYnV0ZXNbbmFtZV0udmFsdWVcbiAgICAgICAgOiB0aGlzLm9wdGlvbnNbbmFtZV07XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBubyBzdWZmaWNpZW50IGZlYXR1cmVzIHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcbiAgICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbWFwIEZpbGVQb25kIGV2ZW50cyB0byBBbmd1bGFyIEBvdXRwdXRzXG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IChlOiBFdmVudCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYG9uJHtlLnR5cGUuc3BsaXQoXCI6XCIpWzFdfWA7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzW2tleV0uZW1pdCh7IC4uLmUuZGV0YWlsIH0pO1xuICAgIH07XG4gICAgb3V0cHV0cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgdGhpcy5yb290Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgYEZpbGVQb25kOiR7ZXZlbnQuc3Vic3RyaW5nKDIpfWAsXG4gICAgICAgIHRoaXMuaGFuZGxlRXZlbnRcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvLyB3aWxsIGJsb2NrIGFuZ3VsYXIgZnJvbSBsaXN0ZW5pbmcgdG8gZXZlbnRzIGluc2lkZSB0aGUgcG9uZFxuICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAvLyBjcmVhdGUgaW5zdGFuY2VcbiAgICAgIHRoaXMucG9uZCA9IGNyZWF0ZShpbnB1dCwge1xuICAgICAgICAvLyBvdXIgb3B0aW9uc1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG5cbiAgICAgICAgLy8gb3VyIGluaXRpYWwgZmlsZXNcbiAgICAgICAgZmlsZXM6IHRoaXMuZmlsZXMsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIENvcHkgaW5zdGFuY2UgbWV0aG9kIHJlZmVyZW5jZXMgdG8gY29tcG9uZW50IGluc3RhbmNlXG4gICAgdGhpcy5wb25kICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnBvbmQpXG5cbiAgICAgICAgLy8gcmVtb3ZlIHVud2FudGVkIG1ldGhvZHNcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBmaWx0ZXJlZENvbXBvbmVudE1ldGhvZHMuaW5kZXhPZihrZXkpID09PSAtMSlcblxuICAgICAgICAvLyBzZXQgbWV0aG9kIHJlZmVyZW5jZXMgZnJvbSB0aGUgY29tcG9uZW50IGluc3RhbmNlIHRvIHRoZSBwb25kIGluc3RhbmNlXG4gICAgICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhpc1trZXldID0gdGhpcy5wb25kW2tleV07XG4gICAgICAgIH0pO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIC8vIG5vIG5lZWQgdG8gaGFuZGxlIGZpcnN0IGNoYW5nZVxuICAgIGlmIChjaGFuZ2VzW1wiZmlyc3RDaGFuZ2VcIl0pIHJldHVybjtcblxuICAgIC8vIG5vIGZpbGVwb25kIGluc3RhbmNlIGF2YWlsYWJsZVxuICAgIGlmICghdGhpcy5wb25kKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXNlIG5ldyBvcHRpb25zIG9iamVjdCBhcyBiYXNlICggb3IgaWYgbm90IGF2YWlsYWJsZSwgdXNlIGN1cnJlbnQgb3B0aW9ucyApXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNoYW5nZXNbXCJvcHRpb25zXCJdXG4gICAgICA/IGNoYW5nZXNbXCJvcHRpb25zXCJdLmN1cnJlbnRWYWx1ZVxuICAgICAgOiB0aGlzLm9wdGlvbnM7XG5cbiAgICAvLyBzZWUgaWYgZmlsZSBsaXN0IGhhcyBjaGFuZ2VkXG4gICAgaWYgKFxuICAgICAgY2hhbmdlc1tcImZpbGVzXCJdICYmXG4gICAgICBKU09OLnN0cmluZ2lmeShjaGFuZ2VzW1wiZmlsZXNcIl0ucHJldmlvdXNWYWx1ZSkgIT09XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGNoYW5nZXNbXCJmaWxlc1wiXS5jdXJyZW50VmFsdWUpXG4gICAgKSB7XG4gICAgICAvLyBmaWxlIGxpc3QgaGFzIGNoYW5nZWRcbiAgICAgIG9wdGlvbnMuZmlsZXMgPSBjaGFuZ2VzW1wiZmlsZXNcIl0uY3VycmVudFZhbHVlO1xuICAgIH1cblxuICAgIC8vIHNldCBuZXcgb3B0aW9uc1xuICAgIHRoaXMucG9uZC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLnBvbmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvdXRwdXRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnJvb3QubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBgRmlsZVBvbmQ6JHtldmVudC5zdWJzdHJpbmcoMil9YCxcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRoaXMucG9uZC5kZXN0cm95KCk7XG4gIH1cbn1cbiIsIjxkaXYgY2xhc3M9XCJmaWxlcG9uZC0td3JhcHBlclwiPlxuICA8aW5wdXQgdHlwZT1cImZpbGVcIi8+XG48L2Rpdj4iXX0=