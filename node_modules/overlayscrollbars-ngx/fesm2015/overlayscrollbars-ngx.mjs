import * as i0 from '@angular/core';
import { Directive, Input, EventEmitter, Component, Output, ViewChild, NgModule } from '@angular/core';
import { OverlayScrollbars } from 'overlayscrollbars';

/* eslint-disable @typescript-eslint/consistent-type-imports */
const createDefer = () => {
    /* istanbul ignore next */
    if (typeof window === 'undefined') {
        // mock ssr calls with "noop"
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const noop = () => { };
        return [noop, noop];
    }
    let idleId;
    let rafId;
    const wnd = window;
    const idleSupported = typeof wnd.requestIdleCallback === 'function';
    const rAF = wnd.requestAnimationFrame;
    const cAF = wnd.cancelAnimationFrame;
    const rIdle = idleSupported ? wnd.requestIdleCallback : rAF;
    const cIdle = idleSupported ? wnd.cancelIdleCallback : cAF;
    const clear = () => {
        cIdle(idleId);
        cAF(rafId);
    };
    return [
        (callback, options) => {
            clear();
            idleId = rIdle(idleSupported
                ? () => {
                    clear();
                    // inside idle its best practice to use rAF to change DOM for best performance
                    rafId = rAF(callback);
                }
                : callback, 
            // @ts-ignore
            typeof options === 'object' ? options : { timeout: 2233 });
        },
        clear,
    ];
};
class OverlayScrollbarsDirective {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.instanceRef = null;
        const [requestDefer, cancelDefer] = createDefer();
        this.requestDefer = requestDefer;
        this.cancelDefer = cancelDefer;
    }
    osInitialize(target) {
        this.ngZone.runOutsideAngular(() => {
            const init = () => {
                this.instanceRef = OverlayScrollbars(target, this.options || {}, 
                /* istanbul ignore next */
                this.events || {});
            };
            if (this.defer) {
                this.requestDefer(init, this.defer);
            }
            else {
                init();
            }
        });
    }
    osInstance() {
        return this.instanceRef;
    }
    ngOnChanges(changes) {
        const optionsChange = changes.options;
        const eventsChange = changes.events;
        if (optionsChange) {
            const curr = optionsChange.currentValue;
            this.options = curr;
            if (OverlayScrollbars.valid(this.instanceRef)) {
                this.instanceRef.options(curr || {}, true);
            }
        }
        /* istanbul ignore else */
        if (eventsChange) {
            const curr = eventsChange.currentValue;
            this.events = curr;
            if (OverlayScrollbars.valid(this.instanceRef)) {
                this.instanceRef.on(
                /* istanbul ignore next */
                curr || {}, true);
            }
        }
    }
    ngOnDestroy() {
        this.cancelDefer();
    }
}
OverlayScrollbarsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayScrollbarsDirective, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
OverlayScrollbarsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.4.0", type: OverlayScrollbarsDirective, selector: "[overlayScrollbars]", inputs: { options: "options", events: "events", defer: "defer" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayScrollbarsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[overlayScrollbars]', // https://angular.io/guide/styleguide#directive-selectors
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; }, propDecorators: { options: [{
                type: Input,
                args: ['options']
            }], events: [{
                type: Input,
                args: ['events']
            }], defer: [{
                type: Input,
                args: ['defer']
            }] } });

/* eslint-disable @typescript-eslint/consistent-type-imports */
const mergeEventListeners = (emits, events) => Object.keys(emits).reduce((obj, name) => {
    const emitListener = emits[name];
    const eventListener = events[name];
    /* istanbul ignore next */
    obj[name] = [
        emitListener,
        ...(Array.isArray(eventListener) ? eventListener : [eventListener]).filter(Boolean),
    ];
    return obj;
}, {});
class OverlayScrollbarsComponent {
    constructor(ngZone, targetRef) {
        this.ngZone = ngZone;
        this.targetRef = targetRef;
        this.onInitialized = new EventEmitter();
        this.onUpdated = new EventEmitter();
        this.onDestroyed = new EventEmitter();
        this.onScroll = new EventEmitter();
    }
    osInstance() {
        return this.osDirective.osInstance();
    }
    getElement() {
        return this.targetRef.nativeElement;
    }
    ngAfterViewInit() {
        const targetElm = this.getElement();
        const contentElm = this.contentRef.nativeElement;
        /* istanbul ignore else */
        if (targetElm && contentElm) {
            this.osDirective.osInitialize({
                target: targetElm,
                elements: {
                    viewport: contentElm,
                    content: contentElm,
                },
            });
        }
    }
    ngOnDestroy() {
        var _a, _b;
        (_b = (_a = this.osDirective) === null || _a === void 0 ? void 0 : _a.osInstance()) === null || _b === void 0 ? void 0 : _b.destroy();
    }
    mergeEvents(originalEvents) {
        return mergeEventListeners({
            initialized: (...args) => this.dispatchEventIfHasObservers(this.onInitialized, args),
            updated: (...args) => this.dispatchEventIfHasObservers(this.onUpdated, args),
            destroyed: (...args) => this.dispatchEventIfHasObservers(this.onDestroyed, args),
            scroll: (...args) => this.dispatchEventIfHasObservers(this.onScroll, args),
        }, originalEvents || {});
    }
    dispatchEventIfHasObservers(eventEmitter, args) {
        // `observed` is available since RxJS@7.2 because `observers` is being deprecated.
        if (eventEmitter.observed || eventEmitter.observers.length > 0) {
            // This is required to re-enter the Angular zone to call the event handler in the Angular
            // zone too. This will not re-enter the Angular zone if emitter doesn't have any observers,
            // for instance, it's being listened: `<overlay-scrollbars (osInitialized)="..."`.
            // Events are dispatched outside of the Angular zone because instance is created in the
            // `<root>` zone, see `OverlayScrollbarsDirective#osInitialize`.
            this.ngZone.run(() => eventEmitter.emit(args));
        }
    }
}
OverlayScrollbarsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayScrollbarsComponent, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
OverlayScrollbarsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.4.0", type: OverlayScrollbarsComponent, selector: "overlay-scrollbars, [overlay-scrollbars]", inputs: { options: "options", events: "events", defer: "defer" }, outputs: { onInitialized: "osInitialized", onUpdated: "osUpdated", onDestroyed: "osDestroyed", onScroll: "osScroll" }, host: { attributes: { "data-overlayscrollbars-initialize": "" } }, viewQueries: [{ propertyName: "contentRef", first: true, predicate: ["content"], descendants: true }, { propertyName: "osDirective", first: true, predicate: ["content"], descendants: true, read: OverlayScrollbarsDirective }], ngImport: i0, template: `
    <div
      overlayScrollbars
      data-overlayscrollbars-contents=""
      [options]="options"
      [events]="mergeEvents(events)"
      [defer]="defer"
      #content
    >
      <ng-content></ng-content>
    </div>
  `, isInline: true, directives: [{ type: OverlayScrollbarsDirective, selector: "[overlayScrollbars]", inputs: ["options", "events", "defer"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayScrollbarsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'overlay-scrollbars, [overlay-scrollbars]',
                    host: { 'data-overlayscrollbars-initialize': '' },
                    template: `
    <div
      overlayScrollbars
      data-overlayscrollbars-contents=""
      [options]="options"
      [events]="mergeEvents(events)"
      [defer]="defer"
      #content
    >
      <ng-content></ng-content>
    </div>
  `,
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ElementRef }]; }, propDecorators: { options: [{
                type: Input,
                args: ['options']
            }], events: [{
                type: Input,
                args: ['events']
            }], defer: [{
                type: Input,
                args: ['defer']
            }], onInitialized: [{
                type: Output,
                args: ['osInitialized']
            }], onUpdated: [{
                type: Output,
                args: ['osUpdated']
            }], onDestroyed: [{
                type: Output,
                args: ['osDestroyed']
            }], onScroll: [{
                type: Output,
                args: ['osScroll']
            }], contentRef: [{
                type: ViewChild,
                args: ['content']
            }], osDirective: [{
                type: ViewChild,
                args: ['content', { read: OverlayScrollbarsDirective }]
            }] } });

class OverlayscrollbarsModule {
}
OverlayscrollbarsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayscrollbarsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OverlayscrollbarsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayscrollbarsModule, declarations: [OverlayScrollbarsComponent, OverlayScrollbarsDirective], exports: [OverlayScrollbarsComponent, OverlayScrollbarsDirective] });
OverlayscrollbarsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayscrollbarsModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayscrollbarsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [OverlayScrollbarsComponent, OverlayScrollbarsDirective],
                    exports: [OverlayScrollbarsComponent, OverlayScrollbarsDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { OverlayScrollbarsComponent, OverlayScrollbarsDirective, OverlayscrollbarsModule };
//# sourceMappingURL=overlayscrollbars-ngx.mjs.map
