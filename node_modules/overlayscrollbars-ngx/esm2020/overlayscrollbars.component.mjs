/* eslint-disable @typescript-eslint/consistent-type-imports */
import { Component, Input, Output, EventEmitter, ViewChild, } from '@angular/core';
import { OverlayScrollbarsDirective } from './overlayscrollbars.directive';
import * as i0 from "@angular/core";
import * as i1 from "./overlayscrollbars.directive";
const mergeEventListeners = (emits, events) => Object.keys(emits).reduce((obj, name) => {
    const emitListener = emits[name];
    const eventListener = events[name];
    /* istanbul ignore next */
    obj[name] = [
        emitListener,
        ...(Array.isArray(eventListener) ? eventListener : [eventListener]).filter(Boolean),
    ];
    return obj;
}, {});
export class OverlayScrollbarsComponent {
    constructor(ngZone, targetRef) {
        this.ngZone = ngZone;
        this.targetRef = targetRef;
        this.onInitialized = new EventEmitter();
        this.onUpdated = new EventEmitter();
        this.onDestroyed = new EventEmitter();
        this.onScroll = new EventEmitter();
    }
    osInstance() {
        return this.osDirective.osInstance();
    }
    getElement() {
        return this.targetRef.nativeElement;
    }
    ngAfterViewInit() {
        const targetElm = this.getElement();
        const contentElm = this.contentRef.nativeElement;
        /* istanbul ignore else */
        if (targetElm && contentElm) {
            this.osDirective.osInitialize({
                target: targetElm,
                elements: {
                    viewport: contentElm,
                    content: contentElm,
                },
            });
        }
    }
    ngOnDestroy() {
        this.osDirective?.osInstance()?.destroy();
    }
    mergeEvents(originalEvents) {
        return mergeEventListeners({
            initialized: (...args) => this.dispatchEventIfHasObservers(this.onInitialized, args),
            updated: (...args) => this.dispatchEventIfHasObservers(this.onUpdated, args),
            destroyed: (...args) => this.dispatchEventIfHasObservers(this.onDestroyed, args),
            scroll: (...args) => this.dispatchEventIfHasObservers(this.onScroll, args),
        }, originalEvents || {});
    }
    dispatchEventIfHasObservers(eventEmitter, args) {
        // `observed` is available since RxJS@7.2 because `observers` is being deprecated.
        if (eventEmitter.observed || eventEmitter.observers.length > 0) {
            // This is required to re-enter the Angular zone to call the event handler in the Angular
            // zone too. This will not re-enter the Angular zone if emitter doesn't have any observers,
            // for instance, it's being listened: `<overlay-scrollbars (osInitialized)="..."`.
            // Events are dispatched outside of the Angular zone because instance is created in the
            // `<root>` zone, see `OverlayScrollbarsDirective#osInitialize`.
            this.ngZone.run(() => eventEmitter.emit(args));
        }
    }
}
OverlayScrollbarsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayScrollbarsComponent, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
OverlayScrollbarsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.4.0", type: OverlayScrollbarsComponent, selector: "overlay-scrollbars, [overlay-scrollbars]", inputs: { options: "options", events: "events", defer: "defer" }, outputs: { onInitialized: "osInitialized", onUpdated: "osUpdated", onDestroyed: "osDestroyed", onScroll: "osScroll" }, host: { attributes: { "data-overlayscrollbars-initialize": "" } }, viewQueries: [{ propertyName: "contentRef", first: true, predicate: ["content"], descendants: true }, { propertyName: "osDirective", first: true, predicate: ["content"], descendants: true, read: OverlayScrollbarsDirective }], ngImport: i0, template: `
    <div
      overlayScrollbars
      data-overlayscrollbars-contents=""
      [options]="options"
      [events]="mergeEvents(events)"
      [defer]="defer"
      #content
    >
      <ng-content></ng-content>
    </div>
  `, isInline: true, directives: [{ type: i1.OverlayScrollbarsDirective, selector: "[overlayScrollbars]", inputs: ["options", "events", "defer"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.4.0", ngImport: i0, type: OverlayScrollbarsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'overlay-scrollbars, [overlay-scrollbars]',
                    host: { 'data-overlayscrollbars-initialize': '' },
                    template: `
    <div
      overlayScrollbars
      data-overlayscrollbars-contents=""
      [options]="options"
      [events]="mergeEvents(events)"
      [defer]="defer"
      #content
    >
      <ng-content></ng-content>
    </div>
  `,
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ElementRef }]; }, propDecorators: { options: [{
                type: Input,
                args: ['options']
            }], events: [{
                type: Input,
                args: ['events']
            }], defer: [{
                type: Input,
                args: ['defer']
            }], onInitialized: [{
                type: Output,
                args: ['osInitialized']
            }], onUpdated: [{
                type: Output,
                args: ['osUpdated']
            }], onDestroyed: [{
                type: Output,
                args: ['osDestroyed']
            }], onScroll: [{
                type: Output,
                args: ['osScroll']
            }], contentRef: [{
                type: ViewChild,
                args: ['content']
            }], osDirective: [{
                type: ViewChild,
                args: ['content', { read: OverlayScrollbarsDirective }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheXNjcm9sbGJhcnMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL292ZXJsYXlzY3JvbGxiYXJzLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrREFBK0Q7QUFDL0QsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixTQUFTLEdBS1YsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sK0JBQStCLENBQUM7OztBQUUzRSxNQUFNLG1CQUFtQixHQUFHLENBQUMsS0FBcUIsRUFBRSxNQUFzQixFQUFFLEVBQUUsQ0FDM0UsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQThCLENBQUMsTUFBTSxDQUNyRCxDQUFpQyxHQUFtQixFQUFFLElBQU8sRUFBRSxFQUFFO0lBQy9ELE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNqQyxNQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbkMsMEJBQTBCO0lBQzFCLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRztRQUNWLFlBQVk7UUFDWixHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQztLQUNwRixDQUFDO0lBQ0YsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDLEVBQ0QsRUFBRSxDQUNILENBQUM7QUFrQkosTUFBTSxPQUFPLDBCQUEwQjtJQXlCckMsWUFBb0IsTUFBYyxFQUFVLFNBQWtDO1FBQTFELFdBQU0sR0FBTixNQUFNLENBQVE7UUFBVSxjQUFTLEdBQVQsU0FBUyxDQUF5QjtRQWI5RSxrQkFBYSxHQUFHLElBQUksWUFBWSxFQUFvQyxDQUFD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QkFBQyxhQUFhO2dCQUdyQixRQUFRO3NCQURQLE1BQU07dUJBQUMsVUFBVTtnQkFJVixVQUFVO3NCQURqQixTQUFTO3VCQUFDLFNBQVM7Z0JBR1osV0FBVztzQkFEbEIsU0FBUzt1QkFBQyxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsMEJBQTBCLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWltcG9ydHMgKi9cclxuaW1wb3J0IHtcclxuICBDb21wb25lbnQsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBWaWV3Q2hpbGQsXHJcbiAgRWxlbWVudFJlZixcclxuICBPbkRlc3Ryb3ksXHJcbiAgQWZ0ZXJWaWV3SW5pdCxcclxuICBOZ1pvbmUsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE92ZXJsYXlTY3JvbGxiYXJzIH0gZnJvbSAnb3ZlcmxheXNjcm9sbGJhcnMnO1xyXG5pbXBvcnQgdHlwZSB7IFBhcnRpYWxPcHRpb25zLCBFdmVudExpc3RlbmVycywgRXZlbnRMaXN0ZW5lckFyZ3MgfSBmcm9tICdvdmVybGF5c2Nyb2xsYmFycyc7XHJcbmltcG9ydCB7IE92ZXJsYXlTY3JvbGxiYXJzRGlyZWN0aXZlIH0gZnJvbSAnLi9vdmVybGF5c2Nyb2xsYmFycy5kaXJlY3RpdmUnO1xyXG5cclxuY29uc3QgbWVyZ2VFdmVudExpc3RlbmVycyA9IChlbWl0czogRXZlbnRMaXN0ZW5lcnMsIGV2ZW50czogRXZlbnRMaXN0ZW5lcnMpID0+XHJcbiAgKE9iamVjdC5rZXlzKGVtaXRzKSBhcyAoa2V5b2YgRXZlbnRMaXN0ZW5lcnMpW10pLnJlZHVjZTxFdmVudExpc3RlbmVycz4oXHJcbiAgICA8TiBleHRlbmRzIGtleW9mIEV2ZW50TGlzdGVuZXJzPihvYmo6IEV2ZW50TGlzdGVuZXJzLCBuYW1lOiBOKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVtaXRMaXN0ZW5lciA9IGVtaXRzW25hbWVdO1xyXG4gICAgICBjb25zdCBldmVudExpc3RlbmVyID0gZXZlbnRzW25hbWVdO1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICBvYmpbbmFtZV0gPSBbXHJcbiAgICAgICAgZW1pdExpc3RlbmVyLFxyXG4gICAgICAgIC4uLihBcnJheS5pc0FycmF5KGV2ZW50TGlzdGVuZXIpID8gZXZlbnRMaXN0ZW5lciA6IFtldmVudExpc3RlbmVyXSkuZmlsdGVyKEJvb2xlYW4pLFxyXG4gICAgICBdO1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSxcclxuICAgIHt9XHJcbiAgKTtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnb3ZlcmxheS1zY3JvbGxiYXJzLCBbb3ZlcmxheS1zY3JvbGxiYXJzXScsIC8vIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9zdHlsZWd1aWRlI2NvbXBvbmVudC1zZWxlY3RvcnNcclxuICBob3N0OiB7ICdkYXRhLW92ZXJsYXlzY3JvbGxiYXJzLWluaXRpYWxpemUnOiAnJyB9LFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8ZGl2XHJcbiAgICAgIG92ZXJsYXlTY3JvbGxiYXJzXHJcbiAgICAgIGRhdGEtb3ZlcmxheXNjcm9sbGJhcnMtY29udGVudHM9XCJcIlxyXG4gICAgICBbb3B0aW9uc109XCJvcHRpb25zXCJcclxuICAgICAgW2V2ZW50c109XCJtZXJnZUV2ZW50cyhldmVudHMpXCJcclxuICAgICAgW2RlZmVyXT1cImRlZmVyXCJcclxuICAgICAgI2NvbnRlbnRcclxuICAgID5cclxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxyXG4gICAgPC9kaXY+XHJcbiAgYCxcclxufSlcclxuZXhwb3J0IGNsYXNzIE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95LCBBZnRlclZpZXdJbml0IHtcclxuICAvKiogT3ZlcmxheVNjcm9sbGJhcnMgb3B0aW9ucy4gKi9cclxuICBASW5wdXQoJ29wdGlvbnMnKVxyXG4gIG9wdGlvbnM/OiBQYXJ0aWFsT3B0aW9ucyB8IGZhbHNlIHwgbnVsbDtcclxuICAvKiogT3ZlcmxheVNjcm9sbGJhcnMgZXZlbnRzLiAqL1xyXG4gIEBJbnB1dCgnZXZlbnRzJylcclxuICBldmVudHM/OiBFdmVudExpc3RlbmVycyB8IGZhbHNlIHwgbnVsbDtcclxuICAvKiogV2hldGhlciB0byBkZWZlciB0aGUgaW5pdGlhbGl6YXRpb24gdG8gYSBwb2ludCBpbiB0aW1lIHdoZW4gdGhlIGJyb3dzZXIgaXMgaWRsZS4gKG9yIHRvIHRoZSBuZXh0IGZyYW1lIGlmIGB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFja2AgaXMgbm90IHN1cHBvcnRlZCkgKi9cclxuICBASW5wdXQoJ2RlZmVyJylcclxuICBkZWZlcj86IGJvb2xlYW4gfCBJZGxlUmVxdWVzdE9wdGlvbnM7XHJcblxyXG4gIEBPdXRwdXQoJ29zSW5pdGlhbGl6ZWQnKVxyXG4gIG9uSW5pdGlhbGl6ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPEV2ZW50TGlzdGVuZXJBcmdzWydpbml0aWFsaXplZCddPigpO1xyXG4gIEBPdXRwdXQoJ29zVXBkYXRlZCcpXHJcbiAgb25VcGRhdGVkID0gbmV3IEV2ZW50RW1pdHRlcjxFdmVudExpc3RlbmVyQXJnc1sndXBkYXRlZCddPigpO1xyXG4gIEBPdXRwdXQoJ29zRGVzdHJveWVkJylcclxuICBvbkRlc3Ryb3llZCA9IG5ldyBFdmVudEVtaXR0ZXI8RXZlbnRMaXN0ZW5lckFyZ3NbJ2Rlc3Ryb3llZCddPigpO1xyXG4gIEBPdXRwdXQoJ29zU2Nyb2xsJylcclxuICBvblNjcm9sbCA9IG5ldyBFdmVudEVtaXR0ZXI8RXZlbnRMaXN0ZW5lckFyZ3NbJ3Njcm9sbCddPigpO1xyXG5cclxuICBAVmlld0NoaWxkKCdjb250ZW50JylcclxuICBwcml2YXRlIGNvbnRlbnRSZWY/OiBFbGVtZW50UmVmPEhUTUxEaXZFbGVtZW50PjtcclxuICBAVmlld0NoaWxkKCdjb250ZW50JywgeyByZWFkOiBPdmVybGF5U2Nyb2xsYmFyc0RpcmVjdGl2ZSB9KVxyXG4gIHByaXZhdGUgb3NEaXJlY3RpdmU/OiBPdmVybGF5U2Nyb2xsYmFyc0RpcmVjdGl2ZTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSwgcHJpdmF0ZSB0YXJnZXRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+KSB7fVxyXG5cclxuICBvc0luc3RhbmNlKCk6IE92ZXJsYXlTY3JvbGxiYXJzIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy5vc0RpcmVjdGl2ZSEub3NJbnN0YW5jZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XHJcbiAgICByZXR1cm4gdGhpcy50YXJnZXRSZWYubmF0aXZlRWxlbWVudDtcclxuICB9XHJcblxyXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgIGNvbnN0IHRhcmdldEVsbSA9IHRoaXMuZ2V0RWxlbWVudCgpO1xyXG4gICAgY29uc3QgY29udGVudEVsbSA9IHRoaXMuY29udGVudFJlZiEubmF0aXZlRWxlbWVudDtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKHRhcmdldEVsbSAmJiBjb250ZW50RWxtKSB7XHJcbiAgICAgIHRoaXMub3NEaXJlY3RpdmUhLm9zSW5pdGlhbGl6ZSh7XHJcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRFbG0sXHJcbiAgICAgICAgZWxlbWVudHM6IHtcclxuICAgICAgICAgIHZpZXdwb3J0OiBjb250ZW50RWxtLFxyXG4gICAgICAgICAgY29udGVudDogY29udGVudEVsbSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5vc0RpcmVjdGl2ZT8ub3NJbnN0YW5jZSgpPy5kZXN0cm95KCk7XHJcbiAgfVxyXG5cclxuICBtZXJnZUV2ZW50cyhvcmlnaW5hbEV2ZW50czogT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnRbJ2V2ZW50cyddKSB7XHJcbiAgICByZXR1cm4gbWVyZ2VFdmVudExpc3RlbmVycyhcclxuICAgICAge1xyXG4gICAgICAgIGluaXRpYWxpemVkOiAoLi4uYXJncykgPT4gdGhpcy5kaXNwYXRjaEV2ZW50SWZIYXNPYnNlcnZlcnModGhpcy5vbkluaXRpYWxpemVkLCBhcmdzKSxcclxuICAgICAgICB1cGRhdGVkOiAoLi4uYXJncykgPT4gdGhpcy5kaXNwYXRjaEV2ZW50SWZIYXNPYnNlcnZlcnModGhpcy5vblVwZGF0ZWQsIGFyZ3MpLFxyXG4gICAgICAgIGRlc3Ryb3llZDogKC4uLmFyZ3MpID0+IHRoaXMuZGlzcGF0Y2hFdmVudElmSGFzT2JzZXJ2ZXJzKHRoaXMub25EZXN0cm95ZWQsIGFyZ3MpLFxyXG4gICAgICAgIHNjcm9sbDogKC4uLmFyZ3MpID0+IHRoaXMuZGlzcGF0Y2hFdmVudElmSGFzT2JzZXJ2ZXJzKHRoaXMub25TY3JvbGwsIGFyZ3MpLFxyXG4gICAgICB9LFxyXG4gICAgICBvcmlnaW5hbEV2ZW50cyB8fCB7fVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGlzcGF0Y2hFdmVudElmSGFzT2JzZXJ2ZXJzPFQ+KGV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyPFQ+LCBhcmdzOiBUKTogdm9pZCB7XHJcbiAgICAvLyBgb2JzZXJ2ZWRgIGlzIGF2YWlsYWJsZSBzaW5jZSBSeEpTQDcuMiBiZWNhdXNlIGBvYnNlcnZlcnNgIGlzIGJlaW5nIGRlcHJlY2F0ZWQuXHJcbiAgICBpZiAoKGV2ZW50RW1pdHRlciBhcyBhbnkpLm9ic2VydmVkIHx8IGV2ZW50RW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIHRvIHJlLWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpbiB0aGUgQW5ndWxhclxyXG4gICAgICAvLyB6b25lIHRvby4gVGhpcyB3aWxsIG5vdCByZS1lbnRlciB0aGUgQW5ndWxhciB6b25lIGlmIGVtaXR0ZXIgZG9lc24ndCBoYXZlIGFueSBvYnNlcnZlcnMsXHJcbiAgICAgIC8vIGZvciBpbnN0YW5jZSwgaXQncyBiZWluZyBsaXN0ZW5lZDogYDxvdmVybGF5LXNjcm9sbGJhcnMgKG9zSW5pdGlhbGl6ZWQpPVwiLi4uXCJgLlxyXG4gICAgICAvLyBFdmVudHMgYXJlIGRpc3BhdGNoZWQgb3V0c2lkZSBvZiB0aGUgQW5ndWxhciB6b25lIGJlY2F1c2UgaW5zdGFuY2UgaXMgY3JlYXRlZCBpbiB0aGVcclxuICAgICAgLy8gYDxyb290PmAgem9uZSwgc2VlIGBPdmVybGF5U2Nyb2xsYmFyc0RpcmVjdGl2ZSNvc0luaXRpYWxpemVgLlxyXG4gICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gZXZlbnRFbWl0dGVyLmVtaXQoYXJncykpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=